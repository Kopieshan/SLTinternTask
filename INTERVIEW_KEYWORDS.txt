═══════════════════════════════════════════════════════════════════════════════
                    DOCKET APP - TECHNICAL INTERVIEW KEYWORDS
                         Key Concepts & Answers Reference
═══════════════════════════════════════════════════════════════════════════════

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
1. FLUTTER FUNDAMENTALS
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Q: What is Flutter?
A: Cross-platform UI framework by Google. Write once, run on Android, iOS, Web, 
   Desktop. Uses Dart language and compiles to native code.

Q: What is Dart?
A: Object-oriented programming language by Google. Used exclusively with Flutter.
   Features: null safety, async/await, strong typing, JIT & AOT compilation.

Q: Widget Tree?
A: Everything in Flutter is a widget. Widgets form a hierarchical tree structure.
   Parent widgets contain child widgets.

Q: StatelessWidget vs StatefulWidget?
A: 
   - StatelessWidget: Immutable, no internal state changes (e.g., Text, Icon)
   - StatefulWidget: Mutable, can change state over time (e.g., form inputs)

Q: What is setState()?
A: Method to notify Flutter that state changed and UI needs rebuilding.
   Used in: Category selection, photo capture, upload progress tracking.

Q: BuildContext?
A: Handle to widget's location in widget tree. Used for navigation, themes,
   showing snackbars, accessing inherited widgets.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
2. STATE MANAGEMENT
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Q: Why setState() for this app?
A: Simple app with local state. No need for complex solutions like Provider, 
   Bloc, Riverpod, or GetX. setState() is performant for single-screen apps.

Q: What state does this app manage?
A: - Selected category (String?)
   - Captured image file (File?)
   - Upload status (bool)
   - Upload progress (double 0.0-1.0)

Q: When is setState() called?
A: - Category dropdown selection
   - Photo captured/cleared
   - Upload starts/ends
   - Progress updates during upload

Q: Alternative state management?
A: Provider, Bloc, Riverpod, GetX, MobX. Not needed here due to simplicity.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
3. FIREBASE INTEGRATION
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Q: What Firebase services are used?
A: 
   1. Firebase Core - Initialization
   2. Firebase Storage - File upload (images)
   3. Cloud Firestore - NoSQL database for metadata

Q: Why Firebase?
A: - Backend-as-a-Service (BaaS)
   - No server management needed
   - Real-time sync, authentication, hosting, analytics
   - Scalable, secure, free tier available

Q: Firebase initialization process?
A: 1. Add dependencies in pubspec.yaml
   2. Run `flutterfire configure` to generate firebase_options.dart
   3. Call Firebase.initializeApp() in main() before runApp()
   4. Enable services in Firebase Console

Q: What is FlutterFire?
A: Official set of Flutter plugins for Firebase. Makes integration easier.

Q: Firebase Storage structure?
A: Path: dockets/temp/[YYYY-MM-DD]_[Category]_0.jpg
   Example: dockets/temp/2025-11-11_Electrical_0.jpg

Q: Firestore data model?
A: Collection: temp_dockets
   Document fields:
   - filename (string)
   - category (string)
   - storagePath (string)
   - downloadURL (string)
   - createdAt (timestamp - server generated)
   - devicePlatform (string: "android" or "ios")

Q: Why serverTimestamp()?
A: Ensures consistent time across all clients regardless of device timezone or
   clock accuracy. Server-side timestamp is authoritative.

Q: Security rules?
A: Currently in test mode (allow all). Production needs:
   - Authentication required
   - User can only access their own data
   - File size/type validation
   - Rate limiting

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
4. IMAGE HANDLING
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Q: How does camera access work?
A: image_picker plugin bridges Flutter to native camera APIs.
   - Android: Uses Intent to launch camera activity
   - iOS: Uses UIImagePickerController

Q: What is image_picker?
A: Flutter plugin for selecting images from gallery or camera.
   Cross-platform, handles permissions, returns File path.

Q: Why image compression?
A: - Reduce storage costs
   - Faster uploads (less bandwidth)
   - Better user experience
   - File size limit: target ≤ 300 KB

Q: Compression strategy?
A: Two-stage approach:
   1. Try quality 85% first
   2. If still > 300 KB, retry with quality 60%
   3. Fallback to original if compression fails
   Uses flutter_image_compress plugin.

Q: What is XFile?
A: Cross-platform file representation from image_picker.
   Convert to File: File(xfile.path)

Q: File storage location?
A: Temporary directory (getTemporaryDirectory from path_provider).
   Cleaned by OS automatically. Not permanent storage.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
5. PERMISSIONS
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Q: Android permissions needed?
A: Declared in AndroidManifest.xml:
   - CAMERA - Access device camera
   - READ_EXTERNAL_STORAGE - Read photos (Android ≤12)
   - WRITE_EXTERNAL_STORAGE - Save photos (Android ≤9)
   - INTERNET - Firebase communication

Q: iOS permissions needed?
A: Declared in Info.plist:
   - NSCameraUsageDescription - Why app needs camera
   - NSPhotoLibraryUsageDescription - Why app reads photos
   - NSPhotoLibraryAddUsageDescription - Why app saves photos

Q: Runtime permissions?
A: image_picker plugin handles runtime permission requests automatically.
   Shows system dialog on first camera access.

Q: What if permission denied?
A: - image_picker returns null
   - App shows error message
   - User must manually enable in device settings

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
6. FILE NAMING CONVENTION
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Q: File naming pattern?
A: [YYYY-MM-DD]_[Category]_0.jpg
   Example: 2025-11-11_Electrical_0.jpg

Q: Why this format?
A: - Sortable by date (YYYY-MM-DD)
   - Identifies category at a glance
   - _0 allows for multiple photos per category per day (future)
   - Readable by humans and systems

Q: Date formatting function?
A: String _formatDateForFilename(DateTime date) {
     return '${date.year}-${date.month.toString().padLeft(2, '0')}-
             ${date.day.toString().padLeft(2, '0')}';
   }
   padLeft ensures 2 digits: 2025-01-05 not 2025-1-5

Q: Why local device date?
A: User perspective matters. File named with their timezone.
   Server timestamp in Firestore for authoritative record.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
7. UPLOAD PROCESS
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Q: Upload flow?
A: 1. User selects category
   2. User takes photo
   3. Compress image
   4. Generate filename with timestamp
   5. Upload to Firebase Storage (track progress)
   6. Get download URL
   7. Write metadata to Firestore
   8. Show success message
   9. Clear UI

Q: Progress tracking?
A: Firebase Storage uploadTask provides snapshotEvents stream.
   Listen to bytesTransferred / totalBytes ratio.
   Update UI with setState() on each progress event.

Q: Why async/await?
A: - Image compression is slow (CPU intensive)
   - Network upload takes time
   - Firestore write needs confirmation
   async/await makes asynchronous code readable.

Q: Error handling strategy?
A: try-catch blocks around:
   - Camera access (permission denied, canceled)
   - Compression (file corruption)
   - Upload (network failure, Firebase error)
   - Firestore write (permission, network)
   Show user-friendly error messages.

Q: Why disable upload button?
A: Prevent:
   - Multiple simultaneous uploads
   - Upload without category
   - Upload without photo
   Better UX with clear state indication.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
8. PLATFORM DETECTION
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Q: How to detect platform?
A: import 'dart:io';
   Platform.isAndroid → true on Android
   Platform.isIOS → true on iOS
   Also: Platform.isWindows, Platform.isMacOS, etc.

Q: Why store platform in Firestore?
A: - Analytics (which platform users prefer)
   - Platform-specific bug tracking
   - Feature usage statistics
   - Support and debugging

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
9. UI/UX DESIGN
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Q: Material Design 3?
A: Latest Material Design guidelines by Google. 
   useMaterial3: true enables it. Modern, adaptive, accessible.

Q: Why Card widgets?
A: - Visual grouping of related content
   - Elevation for depth perception
   - Consistent spacing and padding
   - Professional appearance

Q: Snackbar vs Dialog?
A: - Snackbar: Non-intrusive, auto-dismiss, for status messages
   - Dialog: Requires user action, for important choices
   This app uses Snackbar for success/error feedback.

Q: Color scheme?
A: ColorScheme.fromSeed(seedColor: Color(0xFF1976D2))
   Generates harmonious color palette from one seed color.
   Primary: #1976D2 (Material Blue)

Q: Responsive design?
A: - SingleChildScrollView prevents overflow on small screens
   - CrossAxisAlignment.stretch makes buttons full width
   - Flexible padding adapts to screen size

Q: Button states?
A: - Enabled: Blue background, white text
   - Disabled: Gray, low opacity
   - Loading: Shows spinner, disabled interaction

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
10. NULL SAFETY
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Q: What is null safety?
A: Dart 2.12+ feature. Variables can't contain null unless explicitly marked.
   String vs String? (nullable)

Q: Nullable types in this app?
A: - String? _selectedCategory (no category selected initially)
   - File? _imageFile (no photo captured initially)

Q: Null operators?
A: - ? : Nullable type (String?)
   - ! : Assert non-null (_imageFile!)
   - ?? : Null coalescing (value ?? default)
   - ?. : Null-aware access (object?.property)

Q: Why null safety matters?
A: Prevents NullPointerException crashes. Catches errors at compile time.
   Safer, more reliable code.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
11. ASYNC PROGRAMMING
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Q: Future vs async/await?
A: - Future: Represents eventual completion of async operation
   - async: Marks function as asynchronous
   - await: Pauses execution until Future completes

Q: Where is async used?
A: - _pickImageFromCamera() - wait for user to take photo
   - _compressImage() - wait for compression
   - _uploadToFirebase() - wait for upload completion
   - Firebase.initializeApp() - wait for initialization

Q: Stream vs Future?
A: - Future: Single value eventually (one-time operation)
   - Stream: Multiple values over time (ongoing events)
   Upload progress uses Stream (snapshotEvents).

Q: Why WidgetsFlutterBinding.ensureInitialized()?
A: Required before calling native code in main() before runApp().
   Ensures Flutter framework is initialized for Firebase.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
12. PACKAGES/DEPENDENCIES
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Q: How to add packages?
A: 1. Add to pubspec.yaml under dependencies
   2. Run `flutter pub get`
   3. Import in Dart files: import 'package:name/name.dart';

Q: Key packages used?
A: 
   firebase_core - Firebase SDK initialization
   firebase_storage - Cloud file storage
   cloud_firestore - NoSQL database
   image_picker - Camera/gallery access
   flutter_image_compress - Image compression
   path - File path manipulation
   path_provider - Access system directories

Q: pub.dev?
A: Official Dart/Flutter package repository. Like npm for Node.js.
   Search packages, check versions, read documentation.

Q: Semantic versioning?
A: ^3.8.1 means:
   - 3 = major version (breaking changes)
   - 8 = minor version (new features, backward compatible)
   - 1 = patch version (bug fixes)
   ^ allows updates: >=3.8.1 <4.0.0

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
13. ERROR HANDLING
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Q: try-catch pattern?
A: try {
     // risky operation
   } catch (e) {
     // handle error
   }
   Used for: camera access, compression, upload, Firestore writes

Q: User-friendly errors?
A: Don't show technical stack traces. Show:
   - "Camera error: Permission denied"
   - "Upload failed: No internet connection"
   - "Firebase not configured"

Q: Common errors?
A: - Camera canceled: User pressed back (return null, don't crash)
   - Permission denied: Show how to enable in settings
   - Network error: Check connection, retry
   - Firebase not initialized: Run flutterfire configure

Q: debugPrint vs print?
A: debugPrint is Flutter-specific:
   - Throttles output to prevent log overflow
   - Only in debug mode
   - Better for development

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
14. BUILD & DEPLOYMENT
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Q: flutter run?
A: Builds and runs app on connected device/emulator.
   Hot reload enabled - see changes instantly.

Q: flutter build?
A: - flutter build apk (Android release)
   - flutter build ios (iOS release)
   - flutter build web (Web release)

Q: Hot reload vs Hot restart?
A: - Hot reload: Inject code changes, preserves state (fast)
   - Hot restart: Restart app, lose state (slower)
   - Full restart: Rebuild everything (slowest)

Q: Debug vs Release mode?
A: - Debug: Slower, debugging tools, asserts enabled
   - Release: Optimized, no debugging, smaller size

Q: Android minSdkVersion?
A: Minimum Android version supported.
   Firebase requires API 21 (Android 5.0 Lollipop, 2014).
   Set in android/app/build.gradle.kts

Q: iOS deployment target?
A: Minimum iOS version. Typically iOS 12.0+.
   Set in ios/Podfile and Xcode project.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
15. TESTING
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Q: Types of testing in Flutter?
A: 
   1. Unit tests - Test functions/classes in isolation
   2. Widget tests - Test UI components
   3. Integration tests - Test complete app flow

Q: Testing strategy for this app?
A: Manual testing checklist:
   - Category selection works
   - Camera opens and captures
   - Photo preview displays
   - Upload button enables/disables correctly
   - Progress tracking works
   - Success message appears
   - Firebase has file and document

Q: flutter test command?
A: Runs all tests in test/ directory.
   This project: Basic widget test included by default.

Q: Why manual testing acceptable?
A: Small app, single feature. Automated tests would take longer to write
   than manual testing. For larger apps, automate everything.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
16. PERFORMANCE
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Q: Performance considerations?
A: - Image compression reduces upload time
   - Async operations don't block UI
   - setState() only rebuilds necessary widgets
   - ListView not needed (single screen, few widgets)

Q: Why compress before upload?
A: - Raw photos: 2-10 MB
   - Compressed: <300 KB (30x smaller!)
   - Faster upload, less bandwidth, lower storage costs

Q: Memory management?
A: - Temporary files cleaned by OS
   - Image cleared after upload
   - No memory leaks (no forgotten listeners)

Q: Network optimization?
A: - Single upload request
   - Progress tracking doesn't consume extra bandwidth
   - Firebase handles retry and resumption

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
17. BEST PRACTICES FOLLOWED
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

✓ Null safety throughout
✓ Const constructors for performance
✓ Clear variable naming
✓ Error handling with try-catch
✓ User feedback (loading states, messages)
✓ Comments explaining complex logic
✓ Separation of concerns (functions for each task)
✓ No hardcoded values (use constants)
✓ Responsive UI (SingleChildScrollView)
✓ Material Design guidelines
✓ Async operations properly awaited
✓ Resources cleaned up (images cleared)

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
18. PROJECT STRUCTURE
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

lib/
  main.dart                 - App entry point, all logic
  firebase_options.dart     - Firebase config (auto-generated)

android/
  app/src/main/
    AndroidManifest.xml     - Android permissions

ios/
  Runner/
    Info.plist              - iOS permissions

pubspec.yaml                - Dependencies

Documentation:
  README.md                 - Main documentation
  QUICKSTART.md             - 5-minute setup
  PROJECT_SUMMARY.md        - Complete guide
  CHECKLIST.md              - Testing checklist
  INTERVIEW_KEYWORDS.txt    - This file

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
19. COMMON INTERVIEW QUESTIONS
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Q: Why Flutter over React Native?
A: - Better performance (compiles to native)
   - Single codebase for all platforms
   - Rich widget library
   - Hot reload
   - Strong Google backing
   - Growing ecosystem

Q: Explain the app architecture?
A: Single-screen MVVM pattern:
   - View: DocketScreen widget (UI)
   - ViewModel: State variables and methods in _DocketScreenState
   - Model: Firebase (data layer)
   Simple setState for state management.

Q: How would you scale this app?
A: - Add authentication (Firebase Auth)
   - Implement Provider/Bloc for complex state
   - Add offline support (local database)
   - Multiple photos per complaint
   - Location tracking
   - Push notifications for status updates
   - Admin dashboard

Q: Security concerns?
A: Current: Test mode rules (insecure)
   Production needs:
   - Require authentication
   - Validate file types server-side
   - Check file size limits
   - Rate limiting
   - Input sanitization
   - HTTPS only

Q: How to improve UX?
A: - Add image preview before upload
   - Allow photo retake
   - Offline queue for uploads
   - Upload history view
   - Search/filter past complaints
   - Photo editing (crop, rotate)
   - Dark mode

Q: Testing strategy for production?
A: - Unit tests: Business logic, file naming, compression
   - Widget tests: UI components, button states
   - Integration tests: Full upload flow
   - Manual testing: Camera on real devices
   - Beta testing: Real users, feedback
   - Monitoring: Crashlytics, Analytics

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
20. TROUBLESHOOTING KNOWLEDGE
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Problem: Firebase initialization error
Solution: Run `flutterfire configure`, ensure firebase_options.dart exists

Problem: Camera doesn't open
Solution: Check permissions in AndroidManifest.xml and Info.plist

Problem: Upload fails
Solution: Enable Storage & Firestore in Firebase Console, check security rules

Problem: Image not compressing
Solution: Fallback to original, check flutter_image_compress installation

Problem: Build fails
Solution: flutter clean && flutter pub get && flutter run

Problem: iOS pod install fails
Solution: cd ios && rm -rf Pods Podfile.lock && pod install

Problem: Null safety errors
Solution: Check all nullable types marked with ?, use ! carefully

Problem: State not updating
Solution: Ensure setState() called when changing state variables

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
21. QUICK FACTS TO MEMORIZE
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

✓ App name: Docket (Complaint Ticket System)
✓ Categories: 5 (Electrical, Plumbing, Cleaning, Security, Other)
✓ Target image size: ≤ 300 KB
✓ File naming: [YYYY-MM-DD]_[Category]_0.jpg
✓ Storage path: dockets/temp/[filename]
✓ Firestore collection: temp_dockets
✓ State management: setState (simple, local state)
✓ Platforms: Android & iOS
✓ Compression: 2-stage (85% then 60% quality)
✓ Progress tracking: 0-100% real-time
✓ Backend: Firebase (Storage + Firestore)
✓ Camera plugin: image_picker
✓ Compression plugin: flutter_image_compress
✓ Language: Dart 3+ with null safety
✓ Framework: Flutter 3.6+
✓ Design: Material Design 3

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
22. CODE SNIPPETS TO KNOW
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

// Firebase initialization
await Firebase.initializeApp(
  options: DefaultFirebaseOptions.currentPlatform,
);

// Date formatting
String _formatDateForFilename(DateTime date) {
  return '${date.year}-${date.month.toString().padLeft(2, '0')}-
          ${date.day.toString().padLeft(2, '0')}';
}

// Camera access
final XFile? photo = await _picker.pickImage(
  source: ImageSource.camera,
  imageQuality: 85,
);

// Compression
XFile? compressed = await FlutterImageCompress.compressAndGetFile(
  file.absolute.path,
  targetPath,
  quality: 85,
);

// Upload to Storage
final storageRef = FirebaseStorage.instance
    .ref()
    .child('dockets/temp/$filename');
final uploadTask = storageRef.putFile(compressedFile);

// Progress tracking
uploadTask.snapshotEvents.listen((TaskSnapshot snapshot) {
  setState(() {
    _uploadProgress = snapshot.bytesTransferred / snapshot.totalBytes;
  });
});

// Firestore write
await FirebaseFirestore.instance.collection('temp_dockets').add({
  'filename': filename,
  'category': category,
  'storagePath': 'dockets/temp/$filename',
  'downloadURL': downloadURL,
  'createdAt': FieldValue.serverTimestamp(),
  'devicePlatform': Platform.isAndroid ? 'android' : 'ios',
});

// Platform detection
final platform = Platform.isAndroid ? 'android' : 'ios';

// Show success message
ScaffoldMessenger.of(context).showSnackBar(
  SnackBar(content: Text('Success!')),
);

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
FINAL TIPS FOR INTERVIEW
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

1. Speak confidently about choices made
2. Explain WHY, not just WHAT
3. Acknowledge limitations (test mode security, no auth)
4. Suggest improvements for production
5. Know the flow: category → photo → compress → upload → Firestore
6. Be ready to explain Firebase vs other backends
7. Understand tradeoffs: setState vs Provider/Bloc
8. Show problem-solving: error handling, edge cases
9. Discuss performance: compression, async operations
10. Demonstrate best practices: null safety, error handling, UX

═══════════════════════════════════════════════════════════════════════════════
                              END OF REFERENCE
═══════════════════════════════════════════════════════════════════════════════
